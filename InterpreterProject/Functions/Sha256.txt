// rightrotate
function ror(x, n)
{
    r = x
    for (i=0, i < n, i=i+1)
    {
        if ((r&1) == 1)
        {
            r = (r >> 1) | (1 << 31)
        }
        else
        {
            r = r >> 1
        }
    }

    return(r)
}

function rev(x)
{
    q = ((x&0xff) << 24) | ((x&0xff00)<<8) | ((x&0x00ff0000)>>8) | ((x&0xff000000)>>24)
    return(q)
}

function revlist(&x)
{
    for (i=0, i<len(x), i=i+1)
    {
        x[i] = rev(x[i])
    }
}

function DumpMsg(m, count)
{
    for (i=0, i < count, i=i+1)
    {
        print(width=2, i, ".  ", width=8, hex, m[i], endl)
    }
}

// msg is an array of ints, each one is a byte long.
function Sha256(&msg)
{
    // Initialize hash values
    // first 32 bits of the fractional parts of the square roots of the first 8 primes 2 through 19
    h0 = rev(0x6a09e667)
    h1 = rev(0xbb67ae85)
    h2 = rev(0x3c6ef372)
    h3 = rev(0xa54ff53a)
    h4 = rev(0x510e527f)
    h5 = rev(0x9b05688c)
    h6 = rev(0x1f83d9ab)
    h7 = rev(0x5be0cd19)

    // Initialize array of round constants
    // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2 through 311
    k = dim[64]
    k = { 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
          0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
          0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
          0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
          0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
          0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
          0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2}
    revlist(k)

    // Padding
    msgLenBits = len(msg) * 8

    // Determine kpad
    n = 0
    kpadbits = 512 * n - msgLenBits - 1 - 64
    while ( kpadbits < 0)
    {
        n = n + 1
        kpadbits = 512 * n - msgLenBits - 1 - 64
    }

    // Create a new msg with the pad
    msgWithPadLenBytes = (msgLenBits + 1 + kpadbits + 64) / 8
    msgWithPad = dim[msgWithPadLenBytes]
    for (i=0, i < len(msg), i = i+1)
    {
        msgWithPad[i] = msg[i]
    }

    kpadbytes = (1+kpadbits) / 8
    currBytes = len(msg)
    msgWithPad[currBytes] = 0x80
    currBytes = currBytes + 1

    for (i=1, i < kpadbytes, i = i + 1)
    {
        msgWithPad[currBytes] = 0
        currBytes = currBytes + 1
    }

    // Write the 64-bit length
    for (i=0, i < 4, i = i + 1)
    {
        msgWithPad[currBytes] = 0
        currBytes = currBytes + 1
    }

    msgWithPad[currBytes] = (msgLenBits >> 24 ) & 0xff
    currBytes = currBytes + 1

    msgWithPad[currBytes] = (msgLenBits >> 16 ) & 0xff
    currBytes = currBytes + 1

    msgWithPad[currBytes] = (msgLenBits >> 8 ) & 0xff
    currBytes = currBytes + 1

    msgWithPad[currBytes] = (msgLenBits) & 0xff
    currBytes = currBytes + 1

    print("Msg Length(L) Bits:  ", msgLenBits, endl)
    print("K Length      Bits:  ", kpadbits, endl)
    print("L+1+K+64      Bits:  ", msgLenBits + 1 + kpadbits + 64, endl)
    print("currBytes         :  ", currBytes, endl)

    // Process the message in successive 512-bit chunks
    w = dim[64]
    chunkCount = msgWithPadLenBytes / 64
    for (chunk = 0, chunk < chunkCount, chunk = chunk + 1)
    {
        print("Processing chunk:  ", chunk, endl)
        chunkStart = chunk * 64
        for (i=0, i < 16, i=i+1)
        {
            word = msgWithPad[chunkStart + i * 4] << 24
            word = word | (msgWithPad[chunkStart + i * 4 + 1] << 16)
            word = word | (msgWithPad[chunkStart + i * 4 + 2] << 8)
            word = word | msgWithPad[chunkStart + i * 4 + 3]
            w[i] = word
        }

        print("Extending the first 16 words...", endl)
        for (i=16, i < 64, i=i+1)
        {
            s0 = (ror(w[i-15], 7) ^ ror(w[i-15],18) ^ (w[i-15]>>3))
            s1 = (ror(w[i-2], 17) ^ ror(w[i-2], 19) ^ (w[i-2]>>10))
            w[i] = w[i-16] + s0 + w[i-7] + s1
        }

        print("After extension...", endl)
        DumpMsg(w, 64)

        a = h0
        b = h1
        c = h2
        d = h3
        e = h4
        f = h5
        g = h6
        h = h7

        print("Compression function main loop...", endl)
        for (i=0, i < 64, i=i+1)
        {
            s1 = ror(e,6) ^ ror(e,11) ^ ror(e,25)
            ch = (e & f) ^ ((~e) & g)
            temp1 = h + s1 + ch + k[i] + w[i]
            s0 = ror(a,2) ^ ror(a,13) ^ ror(a,22)
            maj = (a&b) ^ (a&c) ^ (b&c)
            temp2 = s0 + maj

            h = g
            g = f
            f = e
            e = d + temp1
            d = c
            c = b
            b = a
            a = temp1 + temp2
        }

        h0 = h0 + a
        h1 = h1 + b
        h2 = h2 + c
        h3 = h3 + d
        h4 = h4 + e
        h5 = h5 + f
        h6 = h6 + g
        h7 = h7 + h
    }

    digest = dim[32]
    q = {h0, h1, h2, h3, h4, h5, h6, h7}
    for (i = 0, i < 8, i=i+1)
    {
        digest[i*4]   = (q[i]>>24) & 0xff
        digest[i*4+1] = (q[i]>>16) & 0xff
        digest[i*4+2] = (q[i]>>8) & 0xff
        digest[i*4+3] = (q[i]) & 0xff
    }
    return(digest)
}

if (main==1)
{
    data = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64}
    mydigest = Sha256(data)
    print("digest", endl)
    for (i=0, i < 32, i=i+1)
    {
        print(width=2, i, ".  ", width=2, fill=0, hex, mydigest[i], endl)
    }
}